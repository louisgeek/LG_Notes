# HashMap

- 内部封装了一个包含key和value的Entry类用于存储 key-value 的键值对，并允许使用null值和null键
- 
- 基于哈希表实现的，具有较高的查询效率
- 初始化默认长度 16，指定长度的情况下不是直接赋给 threshold 使用，而是通过一个计算赋给 threshold
- 



## 装载因子、装载系数

装载因子的阈值默认为 0.75，当装填因子大于 0.75 时则会触发 HashMap 的扩容机制



## Rehash

扩容并不是在原数组基础上扩大容量，而是需要申请一个长度为原来2倍的新数组

扩容之后就需要将原来的数据从旧数组中重新散列存放到扩容后的新数组。这个过程我们称之为Rehash

操作将会重新散列扩容前已经存储的数据，这一操作涉及大量的元素移动，是一个非常消耗性能的操作。因此，在开发中我们应该尽量避免Rehash的出现。比如，可以预估元素的个数，事先指定哈希表的长度，这样可以有效减少Rehash



## 存储结构

- 是一个“链表散列”的数据结构
- 链地址法处理冲突
- 在put操作中会根据key的hashcode计算在哈希表中的存储位置，并将Entry存入该位置。由于存在Hash冲突的情况，HashMap采用了链地址法来处理Hash冲突。即使用链表的形式将相同哈希值的元素连起来
- 在HashMap的get方法中计算key的哈希值，并定位到元素所在桶的位置，接着使用equals方法查找到目标元素



## 多线程并发中存在的死循环、丢失数据问题







## JDK1.8 中的优化

JDK1.7 中，HashMap 采用位桶 + 链表的实现，即使用链表来处理冲突，同一 hash 值的链表都存储在一个数组中。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。如下图所示的元素查找效率直接降低为了链表的时间复杂度o(n) 

为了优化这一问题，JDK 1.8 在底层结构方面做了一些改变，当每个桶中元素大于 8 的时候，会转变为红黑树，而红黑树的查找效率为o(logn)，高于链表的查找效率