# 面向对象设计的基本原则



## 单一职责原则

- Single Responsibility Principle 单一功能原则

一个类只负责一件事，只有一个引起它变化的原因，是 SOLID 所有原则的基础和解决问题的思路

- 定义：**一个类或者模块，只有一个引起它变化的原因。应该只有一个职责。**
- 解析：如果一个类中承担过多的职责，就导致职责相互耦合，一个职责变化有个可能就会影响其他职责，而且影响复用。

不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分



## 开闭原则

- Open Close Principle

软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的，是直接保障代码质量的原则，用来解决设计的脆弱性、僵化、难以阅读、难以复用等问题，应用开闭原则的关键在于如何 “抽象”

**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点

定义：**一个实体（类、函数、模块等），对扩展开放，对修改关闭。**

解析：在程序扩展时，应该不要修改原有的代码，通过增加新的实体来扩展功能，这样是为了使程序的扩展性好，易于维护和升级，而达到这样的效果，需要使用接口或者抽象类来实现

 



## 里氏替换原则

- Liskov Substitution Principle 里氏代换原则

若对每个类型 S 的对象 o1，都存在一个类型 T 的对象 o2，使得在所有针对 T 编写的程序 P 中，使用 o1 替换 o2 后，程序 P 行为功能不变，则 S 是 T 的子类型，确保子类和父类是 "is a" 的关系，来帮助实现开闭原则。该原则的使用中，引申出面向对象角度的 "is a" 是关于行为的，以及模型的正确性不是内在的，而是由它的客户程序来体现

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范

 定义：子类替换父类。
解析：里氏代换原则是开闭原则的补充。通过继承抽象接口或者类的方式，让子类复用父类&扩展。

任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它

 



## 接口隔离原则

- Interface Segregation Principle

不应该强制客户代码依赖它不需要的方法，提供了一种方案，在不违反里氏替换原则的情况下，如何实现开闭原则。同时接口隔离的思想本身也体现了单一职责原则

使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合

- 定义：**使用多个隔离的接口，比使用单个接口要好。**
- 解析：不要把所有功能抽象为一个接口，应把不同的功能抽象多个不同的接口，降低耦合与依赖

每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好



## 依赖反转原则

- Dependency Inversion Principle 依赖倒置原则 依赖倒转原则

高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象，是过程式设计与面向对象设计的分水岭，通过适当的抽象，让高层模块和底层模块同样地可复用和可测试。同时它也被用来指导接口隔离原则

是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

定义：针对接口编程，依赖于抽象而不依赖于具体。
解析：依赖倒转原则是开闭原则的基础。在2个实体相互依赖时，应尽可能依赖其接口或者抽象类，不要依赖具体的实现类

面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。









**Demeter Principle** 

定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得功能模块相对独立。
解析：在一个模块改变时，应避免影响其他模块，因此如果模块间需要交互时，最好通过一个中间者把它们关联起来，让任一个模块扩展或者修改都不会影响其他模块。

 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

 

 

、**Composite Reuse Principle****合成复用原则**

定义：**在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。**

解析：新对象在创建时，发现某些已有的对象应该拥有新对象部分功能，因在新对象中可以引用这些对象。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

 尽量首先使用合成/聚合的方式，而不是使用继承。